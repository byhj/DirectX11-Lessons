
cbuffer Material
{
  float4 ambient;
  float4 diffuse;
  float4 specular;
  float4 emissive;
  float  shininess;
};

struct VS_OUT
{
    float4 Pos    : SV_POSITION;
	float3 Normal : NORMAL;
	float2 Tex    : TEXCOORD0;
	float3 worldPos : POSITION;
};

Texture2D tex	      : register(t0);
SamplerState texState : register(s0);

Texture2D tex1		   : register(t1);
SamplerState texState1 : register(s1);

float4 PS(VS_OUT ps_in) : SV_TARGET
{
   float3 lightPos = float3(0.0f, 0.0f, 10.0f);
   float3 lightDir = float3(0.0f, 0.0f, 10.0f);

   float4 texColor = tex.Sample(texState, ps_in.Tex);
   ps_in.Normal   = normalize(ps_in.Normal);

   float3 lightToPos = lightPos - ps_in.worldPos;
   float  len = length(lightToPos);

   lightToPos   = normalize(lightToPos);
   float intensity = dot(lightToPos, ps_in.Normal);

   float4 dif = max(intensity, 0.0f) * diffuse ;


	//Load normal from normal map
	float4 normalMap = ObjNormMap.Sample( ObjSamplerState, input.TexCoord );

	//Change normal map range from [0, 1] to [-1, 1]
	normalMap = (2.0f*normalMap) - 1.0f;

	//Make sure tangent is completely orthogonal to normal
	input.tangent = normalize(input.tangent - dot(input.tangent, input.normal)*input.normal);
	float3 biTangent = cross(input.normal, input.tangent);
	float3x3 texSpace = float3x3(input.tangent, biTangent, input.normal);

	//Convert normal from normal map to texture space and store in input.normal
	input.normal = normalize(mul(normalMap, texSpace));
	finalColor = diffuse * light.ambient;
	finalColor += saturate(dot(light.dir, input.normal) * light.diffuse * diffuse);
}